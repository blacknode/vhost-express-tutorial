/*!
 * UglifyJS - middleware (adapted from the less middleware)
 * MIT Licensed
 *
 * Copyright (C) 2013 Chris Box <c.j.box00+github@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

var uglify = require('uglify-js'),
	fs = require('fs'),
	url = require('url'),
	path = require('path'),
	coffee = require('coffee-script'),
	mkdirp = require('mkdirp');

var cache = {};

module.exports = uglify.middleware = function(options) {
	var regex = {
		handle: /\.js$/,
		compress: /(\.|-)(ugly)\.js$/
	};

	options = options || {};

	// Accept src/dest dir
	if ('string' === typeof options) {
		options = { src: options };
	}

	// Only log if in debug mode
	var log = function(key, val, type) {
		if(options.debug || type === 'error') {
			switch(type) {
				case 'log':
				case 'info':
				case 'error':
				case 'warn':
					break;
				default:
					type = 'log';
			}

			console[type]('  \033[90m%s :\033[0m \033[36m%s\033[0m', key, val);
		}
	};

	var uglifyError = function(err) {
		log("Uglify " + err.type + ' error', err.message, 'error');
		log("Uglify File", err.filename + ' ' + err.line + ':' + err.column, 'error');
	};

	// Once option
	options.once = options.once || false;

	// Compress option
//	options.compress = typeof options.compress === 'undefined' ? 'auto' : options.compress;
	options.compress = typeof options.compress === 'undefined' ? true : !!options.compress;

	// Source dir required
	var src = options.src;
	if (!src) { throw new Error('uglify.middleware() requires "src" directory'); }

	// Default dest dir to source
	var dest = options.dest ? options.dest : src;

	if (typeof options.compressFilter != 'undefined') {
		regex.compress = options.compressFilter;
	}

	// Middleware
	return function(req, res, next) {
		if ('GET' != req.method.toUpperCase() && 'HEAD' != req.method.toUpperCase()) { return next(); }

		var pathname = url.parse(req.url).pathname;

		// Only handle the matching files
		if (regex.handle.test(pathname)) {
			if (options.prefix && 0 === pathname.indexOf(options.prefix)) {
				pathname = pathname.substring(options.prefix.length);
			}

			var isCoffeeScript = false;
			var wantCompress = regex.compress.test(pathname);
			var doCompress = options.compress && wantCompress;
			var outPath = path.join(dest, pathname);
			var inPath = path.join(src, (
				wantCompress
					? pathname.replace(regex.compress, '.js')
					: pathname));

			if (!fs.existsSync(inPath)) {
				inPath = inPath.replace(/[.]js$/, ".coffee");
				isCoffeeScript = true;
				if (!fs.existsSync(inPath)) {
					return next(null);
				}
			}

			log('source', inPath);
			log('dest', outPath);

			// Ignore ENOENT to fall through as 404
			function error(err) {
				return next('ENOENT' == err.code ? null : err);
			};

			// Compile to outPath
			function compile() {
				log('read', inPath);

				fs.readFile(inPath, 'utf8', function(err, str){
					if (err) {
						return error(err);
					}
					delete cache[outPath];

					try {
						log('compiling', inPath);
						if(isCoffeeScript) {
							log('compiling coffeescript', inPath);
							str = coffee.compile(str, {});
						}
						var uglified = doCompress ? uglify.minify(str, { fromString: true }).code : str;
						cache[outPath] = true;

						mkdirp(path.dirname(outPath), 0777, function(err){
							if (err) {
								return error(err);
							}

							fs.writeFile(outPath, uglified, 'utf8', next);
						});
					} catch (err) {
						uglifyError(err);
						return next(err);
					}
				});
			};

			// Force
			if (options.force) {
				log('forced', outPath);
				return compile();
			}

			// always compile at least once per server restart, in case
			// the options have changed
			if(!cache[outPath]) {
				log('uncompiled in this session', outPath);
				return compile();
			}

			// Only check/recompile if it has not been done at before
			if (options.once && cache[outPath]) {
				return next();
			}

			// Compare mtimes
			fs.stat(inPath, function(err, inStats){
				if (err) {
					return error(err);
				}

				fs.stat(outPath, function(err, outStats){
					// CSS has not been compiled, compile it!
					if (err) {
						log('uncompiled', outPath);
						if ('ENOENT' == err.code) {
							log('not found', outPath);

							// No file found in dest
							return compile();
						} else {
							return next(err);
						}
					} else if (inStats.mtime > outStats.mtime) {
						// Source has changed, compile it
						log('modified', outPath);

						return compile();
					} else {
						log('unmodified', outPath);
						return next();
					}
				});
			});
		} else {
			return next();
		}
	};
};